/* Copyright (c) 2013-2014, Cornell University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of HyperDex nor the names of its contributors may be
 *       used to endorse or promote products derived from this software without
 *       specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This file is generated by bindings/ruby.py */

static VALUE
hyperdex_ruby_client_asynccall__spacename_key__status_attributes(int64_t (*f)(struct hyperdex_client *client, const char *space, const char *key, size_t key_sz, enum hyperdex_client_returncode *status, const struct hyperdex_client_attribute **attrs, size_t *attrs_sz), VALUE self, VALUE spacename, VALUE key)
{
	VALUE op;
	const char *in_space;
	const char *in_key;
	size_t in_key_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_key(o->arena, key, &in_key, &in_key_sz);
	o->reqid = f(client, in_space, in_key, in_key_sz, &o->status, &o->attrs, &o->attrs_sz);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status_attributes;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_attributenames__status_attributes(int64_t (*f)(struct hyperdex_client *client, const char *space, const char *key, size_t key_sz, const char **attrnames, size_t attrnames_sz, enum hyperdex_client_returncode *status, const struct hyperdex_client_attribute **attrs, size_t *attrs_sz), VALUE self, VALUE spacename, VALUE key, VALUE attributenames)
{
	VALUE op;
	const char *in_space;
	const char *in_key;
	size_t in_key_sz;
	const char **in_attrnames;
	size_t in_attrnames_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_key(o->arena, key, &in_key, &in_key_sz);
	hyperdex_ruby_client_convert_attributenames(o->arena, attributenames, &in_attrnames, &in_attrnames_sz);
	o->reqid = f(client, in_space, in_key, in_key_sz, in_attrnames, in_attrnames_sz, &o->status, &o->attrs, &o->attrs_sz);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status_attributes;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_attributes__status(int64_t (*f)(struct hyperdex_client *client, const char *space, const char *key, size_t key_sz, const struct hyperdex_client_attribute *attrs, size_t attrs_sz, enum hyperdex_client_returncode *status), VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE op;
	const char *in_space;
	const char *in_key;
	size_t in_key_sz;
	const struct hyperdex_client_attribute *in_attrs;
	size_t in_attrs_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_key(o->arena, key, &in_key, &in_key_sz);
	hyperdex_ruby_client_convert_attributes(o->arena, attributes, &in_attrs, &in_attrs_sz);
	o->reqid = f(client, in_space, in_key, in_key_sz, in_attrs, in_attrs_sz, &o->status);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(int64_t (*f)(struct hyperdex_client *client, const char *space, const char *key, size_t key_sz, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, const struct hyperdex_client_attribute *attrs, size_t attrs_sz, enum hyperdex_client_returncode *status), VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE op;
	const char *in_space;
	const char *in_key;
	size_t in_key_sz;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	const struct hyperdex_client_attribute *in_attrs;
	size_t in_attrs_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_key(o->arena, key, &in_key, &in_key_sz);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	hyperdex_ruby_client_convert_attributes(o->arena, attributes, &in_attrs, &in_attrs_sz);
	o->reqid = f(client, in_space, in_key, in_key_sz, in_checks, in_checks_sz, in_attrs, in_attrs_sz, &o->status);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(int64_t (*f)(struct hyperdex_client *client, const char *space, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, const struct hyperdex_client_attribute *attrs, size_t attrs_sz, enum hyperdex_client_returncode *status, uint64_t *count), VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE op;
	const char *in_space;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	const struct hyperdex_client_attribute *in_attrs;
	size_t in_attrs_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	hyperdex_ruby_client_convert_attributes(o->arena, attributes, &in_attrs, &in_attrs_sz);
	o->reqid = f(client, in_space, in_checks, in_checks_sz, in_attrs, in_attrs_sz, &o->status, &o->count);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status_count;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key__status(int64_t (*f)(struct hyperdex_client *client, const char *space, const char *key, size_t key_sz, enum hyperdex_client_returncode *status), VALUE self, VALUE spacename, VALUE key)
{
	VALUE op;
	const char *in_space;
	const char *in_key;
	size_t in_key_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_key(o->arena, key, &in_key, &in_key_sz);
	o->reqid = f(client, in_space, in_key, in_key_sz, &o->status);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_predicates__status(int64_t (*f)(struct hyperdex_client *client, const char *space, const char *key, size_t key_sz, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, enum hyperdex_client_returncode *status), VALUE self, VALUE spacename, VALUE key, VALUE predicates)
{
	VALUE op;
	const char *in_space;
	const char *in_key;
	size_t in_key_sz;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_key(o->arena, key, &in_key, &in_key_sz);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	o->reqid = f(client, in_space, in_key, in_key_sz, in_checks, in_checks_sz, &o->status);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_predicates__status_count(int64_t (*f)(struct hyperdex_client *client, const char *space, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, enum hyperdex_client_returncode *status, uint64_t *count), VALUE self, VALUE spacename, VALUE predicates)
{
	VALUE op;
	const char *in_space;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	o->reqid = f(client, in_space, in_checks, in_checks_sz, &o->status, &o->count);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status_count;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(int64_t (*f)(struct hyperdex_client *client, const char *space, const char *key, size_t key_sz, const struct hyperdex_client_map_attribute *mapattrs, size_t mapattrs_sz, enum hyperdex_client_returncode *status), VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE op;
	const char *in_space;
	const char *in_key;
	size_t in_key_sz;
	const struct hyperdex_client_map_attribute *in_mapattrs;
	size_t in_mapattrs_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_key(o->arena, key, &in_key, &in_key_sz);
	hyperdex_ruby_client_convert_mapattributes(o->arena, mapattributes, &in_mapattrs, &in_mapattrs_sz);
	o->reqid = f(client, in_space, in_key, in_key_sz, in_mapattrs, in_mapattrs_sz, &o->status);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(int64_t (*f)(struct hyperdex_client *client, const char *space, const char *key, size_t key_sz, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, const struct hyperdex_client_map_attribute *mapattrs, size_t mapattrs_sz, enum hyperdex_client_returncode *status), VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE op;
	const char *in_space;
	const char *in_key;
	size_t in_key_sz;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	const struct hyperdex_client_map_attribute *in_mapattrs;
	size_t in_mapattrs_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_key(o->arena, key, &in_key, &in_key_sz);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	hyperdex_ruby_client_convert_mapattributes(o->arena, mapattributes, &in_mapattrs, &in_mapattrs_sz);
	o->reqid = f(client, in_space, in_key, in_key_sz, in_checks, in_checks_sz, in_mapattrs, in_mapattrs_sz, &o->status);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(int64_t (*f)(struct hyperdex_client *client, const char *space, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, const struct hyperdex_client_map_attribute *mapattrs, size_t mapattrs_sz, enum hyperdex_client_returncode *status, uint64_t *count), VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE op;
	const char *in_space;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	const struct hyperdex_client_map_attribute *in_mapattrs;
	size_t in_mapattrs_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	hyperdex_ruby_client_convert_mapattributes(o->arena, mapattributes, &in_mapattrs, &in_mapattrs_sz);
	o->reqid = f(client, in_space, in_checks, in_checks_sz, in_mapattrs, in_mapattrs_sz, &o->status, &o->count);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status_count;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_iterator__spacename_predicates__status_attributes(int64_t (*f)(struct hyperdex_client *client, const char *space, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, enum hyperdex_client_returncode *status, const struct hyperdex_client_attribute **attrs, size_t *attrs_sz), VALUE self, VALUE spacename, VALUE predicates)
{
	VALUE op;
	const char *in_space;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_iterator *o;
	op = rb_class_new_instance(1, &self, class_iterator);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_iterator, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	o->reqid = f(client, in_space, in_checks, in_checks_sz, &o->status, &o->attrs, &o->attrs_sz);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_iterator_encode_status_attributes;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_predicates__status_description(int64_t (*f)(struct hyperdex_client *client, const char *space, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, enum hyperdex_client_returncode *status, const char **description), VALUE self, VALUE spacename, VALUE predicates)
{
	VALUE op;
	const char *in_space;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_deferred *o;
	op = rb_class_new_instance(1, &self, class_deferred);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_deferred, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	o->reqid = f(client, in_space, in_checks, in_checks_sz, &o->status, &o->description);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_deferred_encode_status_description;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}

static VALUE
hyperdex_ruby_client_iterator__spacename_predicates_sortby_limit_maxmin__status_attributes(int64_t (*f)(struct hyperdex_client *client, const char *space, const struct hyperdex_client_attribute_check *checks, size_t checks_sz, const char *sort_by, uint64_t limit, int maxmin, enum hyperdex_client_returncode *status, const struct hyperdex_client_attribute **attrs, size_t *attrs_sz), VALUE self, VALUE spacename, VALUE predicates, VALUE sortby, VALUE limit, VALUE maxmin)
{
	VALUE op;
	const char *in_space;
	const struct hyperdex_client_attribute_check *in_checks;
	size_t in_checks_sz;
	const char *in_sort_by;
	uint64_t in_limit;
	int in_maxmin;
	struct hyperdex_client *client;
	struct hyperdex_ruby_client_iterator *o;
	op = rb_class_new_instance(1, &self, class_iterator);
	rb_iv_set(self, "tmp", op);
	Data_Get_Struct(self, struct hyperdex_client, client);
	Data_Get_Struct(op, struct hyperdex_ruby_client_iterator, o);
	hyperdex_ruby_client_convert_spacename(o->arena, spacename, &in_space);
	hyperdex_ruby_client_convert_predicates(o->arena, predicates, &in_checks, &in_checks_sz);
	hyperdex_ruby_client_convert_sortby(o->arena, sortby, &in_sort_by);
	hyperdex_ruby_client_convert_limit(o->arena, limit, &in_limit);
	hyperdex_ruby_client_convert_maxmin(o->arena, maxmin, &in_maxmin);
	o->reqid = f(client, in_space, in_checks, in_checks_sz, in_sort_by, in_limit, in_maxmin, &o->status, &o->attrs, &o->attrs_sz);
	if (o->reqid < 0)
	{
		hyperdex_ruby_client_throw_exception(o->status, hyperdex_client_error_message(client));
	}
	o->encode_return = hyperdex_ruby_client_iterator_encode_status_attributes;
	rb_hash_aset(rb_iv_get(self, "ops"), LONG2NUM(o->reqid), op);
	rb_iv_set(self, "tmp", Qnil);
	return op;
}
static VALUE
hyperdex_ruby_client_get(VALUE self, VALUE spacename, VALUE key)
{
	return hyperdex_ruby_client_asynccall__spacename_key__status_attributes(hyperdex_client_get, self, spacename, key);
}
VALUE
hyperdex_ruby_client_wait_get(VALUE self, VALUE spacename, VALUE key)
{
	VALUE deferred = hyperdex_ruby_client_get(self, spacename, key);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_get_partial(VALUE self, VALUE spacename, VALUE key, VALUE attributenames)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributenames__status_attributes(hyperdex_client_get_partial, self, spacename, key, attributenames);
}
VALUE
hyperdex_ruby_client_wait_get_partial(VALUE self, VALUE spacename, VALUE key, VALUE attributenames)
{
	VALUE deferred = hyperdex_ruby_client_get_partial(self, spacename, key, attributenames);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_put(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_put, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_put(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_put(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_put(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_put, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_put(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_put(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_put_or_create(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_put_or_create, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_put_or_create(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_put_or_create(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_put(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_put, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_put(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_put(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_put_if_not_exist(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_put_if_not_exist, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_put_if_not_exist(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_put_if_not_exist(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_del(VALUE self, VALUE spacename, VALUE key)
{
	return hyperdex_ruby_client_asynccall__spacename_key__status(hyperdex_client_del, self, spacename, key);
}
VALUE
hyperdex_ruby_client_wait_del(VALUE self, VALUE spacename, VALUE key)
{
	VALUE deferred = hyperdex_ruby_client_del(self, spacename, key);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_del(VALUE self, VALUE spacename, VALUE key, VALUE predicates)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates__status(hyperdex_client_cond_del, self, spacename, key, predicates);
}
VALUE
hyperdex_ruby_client_wait_cond_del(VALUE self, VALUE spacename, VALUE key, VALUE predicates)
{
	VALUE deferred = hyperdex_ruby_client_cond_del(self, spacename, key, predicates);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_del(VALUE self, VALUE spacename, VALUE predicates)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates__status_count(hyperdex_client_group_del, self, spacename, predicates);
}
VALUE
hyperdex_ruby_client_wait_group_del(VALUE self, VALUE spacename, VALUE predicates)
{
	VALUE deferred = hyperdex_ruby_client_group_del(self, spacename, predicates);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_add, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_add(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_add, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_add(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_add(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_add, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_add(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_add(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_sub, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_sub(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_sub, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_sub(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_sub(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_sub, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_sub(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_sub(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_mul, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_mul(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_mul, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_mul(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_mul(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_mul, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_mul(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_mul(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_div, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_div(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_div, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_div(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_div(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_div, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_div(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_div(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_mod, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_mod(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_mod, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_mod(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_mod(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_mod, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_mod(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_mod(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_and, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_and(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_and, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_and(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_and(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_and, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_and(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_and(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_or, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_or(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_or, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_or(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_or(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_or, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_or(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_or(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_xor, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_xor(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_xor, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_xor(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_xor(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_xor, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_xor(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_xor(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_min(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_min, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_min(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_min(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_min(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_min, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_min(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_min(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_min(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_min, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_min(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_min(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_max(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_max, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_max(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_atomic_max(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_max(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_max, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_max(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_atomic_max(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_atomic_max(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_atomic_max, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_atomic_max(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_atomic_max(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_string_prepend, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_string_prepend(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_string_prepend, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_string_prepend(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_string_prepend(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_string_prepend, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_string_prepend(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_string_prepend(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_string_append(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_string_append, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_string_append(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_string_append(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_string_append(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_string_append, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_string_append(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_string_append(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_string_append(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_string_append, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_string_append(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_string_append(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_string_ltrim(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_string_ltrim, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_string_ltrim(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_string_ltrim(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_string_ltrim(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_string_ltrim, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_string_ltrim(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_string_ltrim(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_string_ltrim(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_string_ltrim, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_string_ltrim(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_string_ltrim(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_string_rtrim(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_string_rtrim, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_string_rtrim(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_string_rtrim(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_string_rtrim(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_string_rtrim, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_string_rtrim(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_string_rtrim(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_string_rtrim(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_string_rtrim, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_string_rtrim(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_string_rtrim(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_list_lpush(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_list_lpush, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_list_lpush(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_list_lpush(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_list_lpush(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_list_lpush, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_list_lpush(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_list_lpush(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_list_lpush(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_list_lpush, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_list_lpush(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_list_lpush(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_list_rpush(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_list_rpush, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_list_rpush(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_list_rpush(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_list_rpush(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_list_rpush, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_list_rpush(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_list_rpush(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_list_rpush(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_list_rpush, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_list_rpush(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_list_rpush(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_set_add(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_set_add, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_set_add(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_set_add(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_set_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_set_add, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_set_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_set_add(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_set_add(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_set_add, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_set_add(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_set_add(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_set_remove(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_set_remove, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_set_remove(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_set_remove(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_set_remove(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_set_remove, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_set_remove(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_set_remove(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_set_remove(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_set_remove, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_set_remove(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_set_remove(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_set_intersect(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_set_intersect, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_set_intersect(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_set_intersect(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_set_intersect(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_set_intersect, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_set_intersect(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_set_intersect(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_set_intersect(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_set_intersect, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_set_intersect(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_set_intersect(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_set_union(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_set_union, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_set_union(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_set_union(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_set_union(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_set_union, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_set_union(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_set_union(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_set_union(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_set_union, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_set_union(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_set_union(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_document_rename(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_document_rename, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_document_rename(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_document_rename(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_document_rename(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_document_rename, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_document_rename(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_document_rename(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_document_rename(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_document_rename, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_document_rename(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_document_rename(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_document_unset(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_document_unset, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_document_unset(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_document_unset(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_document_unset(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_document_unset, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_document_unset(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_document_unset(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_document_unset(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_document_unset, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_document_unset(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_document_unset(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_add(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_add, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_add(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_add(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_add, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_add(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_add(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_add, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_add(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_add(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_remove(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_map_remove, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_map_remove(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_map_remove(self, spacename, key, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_remove(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_map_remove, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_remove(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_remove(self, spacename, key, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_remove(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_attributes__status_count(hyperdex_client_group_map_remove, self, spacename, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_remove(VALUE self, VALUE spacename, VALUE predicates, VALUE attributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_remove(self, spacename, predicates, attributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_add, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_add(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_add, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_add(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_add(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_add, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_add(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_add(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_sub, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_sub(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_sub, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_sub(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_sub(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_sub, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_sub(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_sub(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_mul, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_mul(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_mul, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_mul(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_mul(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_mul, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_mul(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_mul(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_div, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_div(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_div, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_div(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_div(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_div, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_div(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_div(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_mod, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_mod(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_mod, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_mod(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_mod(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_mod, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_mod(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_mod(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_and, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_and(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_and, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_and(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_and(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_and, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_and(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_and(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_or, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_or(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_or, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_or(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_or(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_or, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_or(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_or(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_xor, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_xor(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_xor, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_xor(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_xor(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_xor, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_xor(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_xor(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_string_prepend, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_string_prepend(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_string_prepend, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_string_prepend(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_string_prepend(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_string_prepend, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_string_prepend(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_string_prepend(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_string_append(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_string_append, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_string_append(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_string_append(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_string_append(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_string_append, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_string_append(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_string_append(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_string_append(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_string_append, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_string_append(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_string_append(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_min(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_min, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_min(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_min(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_min(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_min, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_min(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_min(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_min(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_min, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_min(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_min(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_max(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_max, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_max(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_map_atomic_max(self, spacename, key, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_max(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_max, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_max(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_cond_map_atomic_max(self, spacename, key, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_group_map_atomic_max(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates_mapattributes__status_count(hyperdex_client_group_map_atomic_max, self, spacename, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_group_map_atomic_max(VALUE self, VALUE spacename, VALUE predicates, VALUE mapattributes)
{
	VALUE deferred = hyperdex_ruby_client_group_map_atomic_max(self, spacename, predicates, mapattributes);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_search(VALUE self, VALUE spacename, VALUE predicates)
{
	return hyperdex_ruby_client_iterator__spacename_predicates__status_attributes(hyperdex_client_search, self, spacename, predicates);
}

static VALUE
hyperdex_ruby_client_search_describe(VALUE self, VALUE spacename, VALUE predicates)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates__status_description(hyperdex_client_search_describe, self, spacename, predicates);
}
VALUE
hyperdex_ruby_client_wait_search_describe(VALUE self, VALUE spacename, VALUE predicates)
{
	VALUE deferred = hyperdex_ruby_client_search_describe(self, spacename, predicates);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_sorted_search(VALUE self, VALUE spacename, VALUE predicates, VALUE sortby, VALUE limit, VALUE maxmin)
{
	return hyperdex_ruby_client_iterator__spacename_predicates_sortby_limit_maxmin__status_attributes(hyperdex_client_sorted_search, self, spacename, predicates, sortby, limit, maxmin);
}

static VALUE
hyperdex_ruby_client_count(VALUE self, VALUE spacename, VALUE predicates)
{
	return hyperdex_ruby_client_asynccall__spacename_predicates__status_count(hyperdex_client_count, self, spacename, predicates);
}
VALUE
hyperdex_ruby_client_wait_count(VALUE self, VALUE spacename, VALUE predicates)
{
	VALUE deferred = hyperdex_ruby_client_count(self, spacename, predicates);
	return rb_funcall(deferred, rb_intern("wait"), 0);
}
